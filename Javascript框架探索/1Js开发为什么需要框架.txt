为了从本质上说明问题，我认为非常有必要先介绍一些互联网、浏览器相关的知识

1969年9月3日，美国加州大学洛杉矶分校（UCLA）雷纳德·克兰罗克（L.Kleinrock）教授实验室内，两部电脑成功地由一条5米长的电缆接驳并互通数据，从这一天开始，计算机网络正式诞生。

随后的20世纪70 80年代，互联网得到了飞速的发展，1990年全球接入互联网的主机超过30万台，但有一个很致命的问题：因为数以万计的主机之间的通讯太过“技术化”，并非普通百姓都可以使用。

于是在1991年，一个划时代的东西出现了：浏览器，人们仅仅需要输入一个IP地址（由点分割开的四个小于255的数字），就可以访问到全世界范围内的计算机，用户通过一个叫网站的东西了解到了外部的世界

1993年，出现了600多个网站，1994年，超过了1万个网站，问题马上来了，这么多网站，对应这么多IP地址，这么多数字，谁记得住啊？于是DNS域名系统出现，实际上DNS在1983年就诞生了，但当时注册域名的人寥寥无几，知道1993年遇到这个问题时才开始流行。

1994年，中国接入互联网

1995年，网站数量超过10万

说了这么多，就是为了引入今天讨论的主角：浏览器，从上述历史介绍中可以发现，浏览器是为了让普通老百姓也能接触到网络才出现的，那我们都怎么使用浏览器呢？首先输入地址（域名），按回车，过一会儿窗口中就出来想要的内容了，接下来页面上会提供很多链接供我们去点，再点一次就会进入到一个新的页面，在某些论坛页面中还提供了若干输入框，让我们输入用户名和密码来注册或登录，从而参与到论坛中的讨论。

=====================================================================================================================

由于JavaScript是运行在浏览器中的，因此我们非常有必要讨论一下浏览器这款客户端应用程序。

1969年互联网诞生，此后得到了飞速的发展，它将全世界各地互联了起来。

1991年一个划时代的东西————浏览器横空出世，自此，互联网走进普通大众的家中，我们只需要输入一个url地址再按下回车这个窗口中就显示出我们想要的内容，早期的时候这些内容通常以文字的形式呈现出来，后来又有了图形化呈现的方式，我们通常把这个窗口和里面的内容叫做网页。

通过以上过程的描述，我们思考一个问题：
在url中输完地址后，计算机在正常联网的状态下会从刚才输入的地址对应的远方的某一台计算机（也就是服务器）中拿到一些数据之后再将其显示到窗口中，我们都知道从远方的那台计算机（服务器）给浏览器传输数据的过程中肯定是通过某些模拟信号（比如光信号）的不同的值（如强光表示1，弱光表示0）来表征0 1 0 1二进制编码，这些模拟信号到达我们用户的浏览器所在的计算机时会被转换成用电信号表征的（如高电平表示1，低电平表示0）0 1 0 1的二进制编码，这些信号通过网线被送到网卡，操作系统会将这些二进制编码会从网卡加载到浏览器管理的内存中，这些二进制编码是如何转换成页面中的一系列文字、图片的呢？

实际上浏览器会调用操作系统提供的接口从而将内存中这些0 1 0 1按照某张码表（例如utf-8、ASCII）翻译成对应的字符序列（例如0x61被翻译成字符a），翻译完成之后的东西我们都很熟悉————html，浏览器拿到这个html片段之后就开始解析，解析的过程无非就是词法分析，语法分析，语义分析，中间代码生成，优化，目标代码生成，最终目标代码调用显卡驱动将各层内容显示给我们。css的解析是同样的道理。需要注意的是在语法解析和语义分析阶段，会构造一棵DOM树和一棵CSS样式树，然后按照css的规则将对应的样式以属性的形式赋给DOM树上的各个节点，这些节点都会以对象的形式存放在内存中

最原始的浏览器非常简单，仅仅显示一些文字、图片、输入框等，浏览器仅仅是把服务器传过来的数据显示出来即可，因此这个阶段的浏览器只有html和css
随着浏览器和服务器之间交互的数据量越来越多，问题开始凸显。一个很典型的场景：在输入框中输入一个关键词，点击搜索，然后网页中给我们显示对应的结果，在早期只有html和css，还没有js的时候这个需求通常会用下面的html代码实现：

<form action="/index.php/resList.html">
	<input type="text" name="swd" />
	<input type="submit" value="点击搜索" />
</form>

点击搜索之后，页面就会跳到当前域下的/index.php/resList.html这个页面中，这个页面包含了我们想要的结果

这样的实现简单易读，但问题也比较严重
假如还没输入或还没输完整想要搜索的内容不小心点了一下搜索按钮，那么接下来将是漫长的等待，然后resList页面中出现一行文字：您输入的结果不能为空，在当时绝大多数用户使用的是速度仅为28.8kbit/s的猫上网，因此每次在客户端进行一次操作希望得到服务器中的某些数据时都是对耐心的一次考验。在诸如登录和注册的过程中对用户输入有某些特殊要求（例如用户名至少5位，且不能有特殊符号）时这种矛盾体现的更为明显。

于是JavaScript便诞生了，是的，JavaScript最初设计之初就是为了解决这样的客户端验证的问题的，这样一来服务器的压力有所降低，作为一门语言，肯定有一些基本的语法，例如变量定义，数据类型，表达式和语句格式，作用域等等，最初这些都是由网景公司自己实现的，后来网景把这些语法规定提交给ECMA International，以便让之后的浏览器制造商遵循该标准，该标准就是ECMAScript的第一个版本。

当然我们知道后来网景被IE打败，IE自己造了一套标准，因此出现了现在这么多的IE兼容问题。

关于ECMA的设计思路有一点非常值得一提：一切皆对象，它规定实现ECMA标准的语言是基于对象的，对象通过构造函数构造出来。同时它也规定了实现ECMA标准的语言必须实现一些最基础的构造函数：Object Function Array String Boolean Number Date，构造函数里面描述对象的各个组成部分（属性和方法），那么我们怎么在脚本中得到一个对象呢？大概有以下两种方法：
1、通过new后面跟构造函数创建对象
2、简化定义方式
举例说明：
var arr = [1, 2, 3]; //这句话和var arr = new Array(1, 2, 3);等价
var obj = {a: 1}; //这句话和var obj = new Object(); obj.a = 1;等价
function fn(){ var a = 3; } //这个函数定义和var fn = new Function("var a = 3;");
var str = "aaa"; //对于基本类型，在程序运行过程中如果调用到了其方法，例如aaa.indexOf("a");会先构建一个new String("aaa")实例化对象，使用完毕之后立即销毁，本质上还是对象

如果想要得到Date的实例化对象，ECMA并没规定实现它的语言必须给我们提供类似上面这种“简化定义方式”，因此只能通过new Date()来创建

ECMA同时也规定实现它的语言必须提供一些对象：Math对象、全局对象，事实上通常构造Math对象和全局对象的函数是Object。

由于同类对象的方法都是一样的（例如[1, 2]和[2, 3]两个数组都有push pop等方法），因此为了避免空间浪费，同类对象的方法都共享在一个公共的对象上，这个对象就是原型对象

原型对象该如何访问到呢？有两种方法：
1、访问实例化对象的__proto__属性
2、访问构造函数的prototype属性（因为所有同类对象都是由同一个构造函数构造出来的，存储所有这些对象的方法的公共对象必然和构造函数有一定关系）

原型对象也是对象，既然是对象，就也应该有__proto__属性，该属性指向原型对象的原型对象，那原型对象的原型对象是一个什么对象呢？

如上所述，我们自己在程序里面创建的这些Function Array String Boolean Number Date的各个实例化对象的__proto__属性的原型对象（例如new Date().__proto__）实际上是一个Object的实例化对象，该实例化对象自然也有__proto__属性（即new Date().__proto__.__proto__），该对象实际上就是Object的原型对象（即Object.prototype）

我们再网上追溯，Object的原型对象也是对象，那么它必然也有__proto__属性，这个属性是谁呢？由于已经到达了最顶层，因此该属性的值为null：
new Date().__proto__.__proto__ === Object.prototype //true
new Date().__proto__.__proto__.__proto__ === null //true

在ECMA的基础之上，浏览器利用这些特性定义了很多构造函数和对象，例如浏览器定义了名为window的全局对象，该对象的构造函数是Window，上面提到浏览器解析html和css时会构造出很多对象，并组成一个树结构，对于html标签，浏览器内部实现了HTMLHtmlElement构造函数，浏览器内部通过new HTMLHtmlElement()会创建出来一个html节点对象，同理页面中的div span img等等都对应一个个对象，也都有各自的构造函数（HTMLDivElement、HTMLSpanElement、HTMLImageElement），因为我们可以给每个html标签添加id作为其唯一标识，因此我们可以在一个script标签中通过该id标识就能访问到该对象：

<body>
    <div id="div1"></div>
    <div id="div2"></div>
    <div id="div3"></div>
</body>
<script>
    console.log(div1); // 访问id为div1的对象
    console.log(div2); // 访问id为div2的对象
    console.log(div3); // 访问id为div3的对象
</script>

在此说明一点，html标签、html节点、html对象说的都是同一个东西，本质上说的都是浏览器在内存中创建的这些代表页面中显示的各个部分的对象

接下来继续，通过div1拿到该对象之后我们可以访问一下它身上的属性，例如：
div1.id // "div1"
div1.tagName // "DIV"

此外，页面上的元素肯定是要和用户交互的，例如用户可以把鼠标指针移入div1这个元素，用户也可以点击div2元素，那么如果希望在用户做这些操作的时候干某些事情，就需要和这个div1、div2对象提前约定好，如何约定呢？通过事件，事件这个属于也是比较形象的，因为用户的点击或移入本身就是一件事情，所以就叫事件。绑定事件有两种方式，比较直接的方式是：
<body>
    <div id="div1"></div>
</body>
<script>
    div1.onclick = function(){
        alert("div1");
    };
</script>
或者给这个事件起一个名字：
<body>
    <div id="div1" onclick="fnClick"></div>
</body>
<script>
    function fnClick(){
		alert("div1);
	}
</script>
这里面fnClick就是我们起的一个名字，这个名字对应一段代码（即函数），通过这个名字我们就可以把它对应的那段代码和div1的点击（onclick）事件联系在一起，由此做到点击时执行这段代码

再回到我们上面提到的那个例子中：
<form action="/index.php/resList.html">
	<input type="text" name="swd" id="swd" />
	<input type="submit" value="点击搜索" id="submit" />
	<span style="display: none;" id="prompt">搜索信息不能为空</span>
</form>
<script>
	submit.onclick = function(){
		if (swd.value == "") {
			prompt.style.display = "block";
			return false;
		}
	};
</script>
通过上面的代码我们就可以实现如果没有输入搜索信息，就显示错误提示的功能

随后在1999年12月，ECMAScript3诞生

============================

现如今我们看到的网页非常复杂，有文字，图片，各种动画，音频，视频等等，不同的文字还可以有不同的字体。而最初的网页则非常简单，追溯历史，最早的一款商用浏览器是Netscape（网景）公司开发的Netscape（网景）浏览器

2、刚才提到论坛类网站在注册的时候，正常的流程是我们输入了用户名和密码，点击注册按钮我们在用户名和密码框中填的这些信息会发给服务器，服务器检查一下用户名是否有重复，如果没有重复就添加到用户数据库中去了，登录时也同理，但是假如某个人犯二了或者手抖了一下，用户名和密码都没有输入就直接点击登录或者注册按钮，这时相当于将空信息发给服务器处理了，服务器拿到这两条空信息发现不对劲，再告诉浏览器用户名或密码不能为空，上个世纪的网速都是奇慢无比的，假如从浏览器到服务器发送这样一条消息要10s钟，服务器给浏览器响应也要10s中，这样仅仅为了检验一下两个输入框里面内容是否为空一来一回20s过去了，这个问题如何解决？

Js用来在浏览器端开发web应用，Js本质上是浏览器提供的一套API，这套接口可以用来操作DOM、进行ajax交互，但由于这套API太过于底层，太过于难用

JavaScript诞生于1995年

jQuery诞生于2006年1月，至今已经有十个年头多了，其作者是美国大神John Resig，他当时发明jQuery的时候只有22岁。

JavaScript发展历史 http://javascript.ruanyifeng.com/introduction/history.html
JavaScript发展历史 http://blog.csdn.net/lzm18064126848/article/details/53575166
搜索引擎发展历史 https://sanwen8.cn/p/3dfJXVS.html
JavaScript作者自述 https://brendaneich.com/2008/04/popularity/
web应用发展历史 http://blog.jobbole.com/45169/
JavaScript维基百科 https://en.wikipedia.org/wiki/JavaScript
ECMAScript维基百科 https://en.wikipedia.org/wiki/ECMAScript
Prototype和jQuery的区别 http://www.jb51.net/article/43538.htm