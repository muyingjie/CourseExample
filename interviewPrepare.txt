面试准备：
工作经验介绍部分：
截止目前，js css所开发的比重大约8:2左右
最近做的一个项目是一个在线商城系统，用户可以在官网上注册一个商城，注册时需要输入一个二级域名，注册成功之后会给用户开通一个商城，用户可以通过这个二级域名访问商城的前台和后台，商城可以免费试用一段时间，试用期到了之后需要购买，对于不同需求、不同行业的商家，提供了不同的模板，如果需要某套模板需要单独购买，用户还可以进入会员中心，在会员中心中可以看到之前产生的商城、模板等订单信息。对于公司内部运营人员还有运营后台，新做的模板可以通过运营后台上传到官网，运营后台中还可以看到所有注册的用户，用户发起的发票申请，商城备案信息等等，此外还有移动端商城
上面提到了几个系统：业务官网、会员中心、商城前台、商城后台、模板市场、运营平台、移动端商城
业务官网：一个普通的企业站，除了登录注册之外没什么复杂交互
会员中心：最开始采用传统的后台渲染方式，后台采用的传统的MVC架构，html页面在控制器中被include进来，控制器中将页面中需要的变量通过assign方法传过去，模板中通过twig模板引擎渲染，后期我用Angular重构了，将渲染的部分放到前端，前端和后台之间通过json传递数据，在前端抽出一个服务来发送请求，该服务会在请求发出之前更新本地存储的最近一次发请求的时间戳，这个时间戳大于设置的session时间时，重定向到登录。
商城前台：和模板市场实际上是一个东西，刚买来商城的时候的前台实际上是就是一套默认模板，数据库中有一张表专门用于存储用户买来了的所有模板，还有一个字段用来存储当前用户使用哪一套模板，模板里面被拆成了很多组件，比如购物车、资讯、版权、logo等等组件，每个组件的模板单独维护，每个组件中的数据都从后台某个模块中的某个类中的某个方法里取到，每个页面里面用一个个标签去代表这一个个组件，类似于JSP页面中的自定义JSP标签，这一套模板里面这么多的后台方法的信息都会统一放到模板文件夹下的一个初始化文件中，这个文件是json格式的，相当于一个很大的配置文件，当切换模板的时候（刚注册开通商城时其实也算一次特殊的切换）会执行一个叫做初始化的操作，这个操作会在模板目录下生成一系列把原来组件解析好之后的页面，当前台访问这个页面的时候再去调用各个方法将其静态化。
商城后台：后台管理系统的页面一般都是左侧导航，点击导航中每一项之后在右侧显示出对应的增删改查的页面，后台PHP依然采用传统的MVC三层架构，前台的架构是外层一个父页面，子页面套了一个iframe，父页面中包含菜单导航，点击菜单中的每一项就刷新iframe中的页面，前端采用了seajs做模块化，这个项目我来了之后基本上做完了，后来商品模块实在是太乱了，我和一位后台的同事合作重构了一遍，添加修改商品的逻辑非常复杂
运营后台：完全是我主导的，用Angular做的，前后台之间也是通过json数据格式交互，后台采用了微服务架构，形式和会员中心差不多
移动端商城：主要用了zepto，css3的一些东西，实际上就相当于一套特殊的模板，后台入口中判断了一下请求是从移动端来的还是从pc端来的，我猜测是通过http请求头来判断的，判断出来是从移动端来的之后读取某一个特殊的模板文件夹下的内容（其实就是专门放移动端模板的那个目录），当然这里面的问题还有非常多，比如pc端的列表页都是同步获取，而移动端是异步获取，pc端和移动端的图片都用了一套，图片尺寸的问题等等

在此之前用Angular做过pc端类似后台管理系统的应用，和Angular+ionic的webapp应用

封装表单校验插件的时候总结出来了一个结论：差别比较大的场合没有必要一定抽象在一起，商场里面的表单校验有两大种交互方式：第一种就是如果表单填写有误就直接在表单后面附加错误，还有一种交互就是表单填写错误时将错误信息同一提示到最上方的一个容器中，当时只是想着得把所有的校验放一起，没想过这两种交互方式差别过大，并不适合放在一起，通过分析，需要多传给插件几个参数，首先得告诉插件是哪种错误校验情况，然后如果是统一放置错误信息的话得再传入放错误信息的容器参数，这样一来就很复杂了，不如把这两种情况分开

基本概念介绍部分：
变量：
函数和预解析机制：放到这里目的是想和后面提到的预解析机制一起说一下，变量和函数的提升就不用说了，只要是前端肯定都知道，我想说的是这里面比较容易出错的地方：首先就是函数分为函数表达式和函数定义，只要不是以function关键字开头的都叫做函数表达式，包括var fn = function(){}; 匿名寒素自执行的情况，函数表达式不进行提升，即使在函数自执行中给函数命了名字，也不会提升，还有就是函数和变量同名时会覆盖变量的声明，但是需要注意在变量声明并赋值的场合中这个名字又被覆盖回去了，因为变量赋值这一步操作紧跟在预解析后面，而且一旦给变量初始化了，咱们开发人员就没有权限在变量和函数提升完毕和变量初始化赋值的中间间隙中做操作了，因此和函数同名的变量赋值之后弹出来这个名字不再是函数。
闭包：
作用域链：
原型链：
事件：
面向对象：
Function.prototype.bind:
设计模式：

1、移动端开发
对于一侧固定，另外一侧自适应的布局用calc("100% - 13rem");

2、对于横向列表
width用百分比、高度写死时，很难实现正方形或者特定比例的效果，而且由于不同屏幕尺寸不同，用百分比的话也会出现各种不同的尺寸，而设计图只有一种尺寸，造成很大的不便，因此我们可以通过js计算出缩放比后动态生成meta标签附加上去

jQuery原理部分：
整体架构和链式调用：
Callbacks回调模块：
Deferred延迟对象模块：
Promise是只读Deferred
Data数据缓存模块：
queue队列模块：
event事件模块：
ajax交互模块：
animate动画模块：

Angular原理部分：
脏检测机制：
表达式编译机制：
依赖注入机制：
指令系统：

chrome调试：

ES6部分：

性能优化部分：

自己遇到的难点：
添加商品的时候组合算法
jQuery内部sizzle引擎：词法解析、语法解析生成AST，当有伪类的时候，按照前序遍历算法执行，没有伪类的时候按照后序遍历算法执行
脏检测时如何提升性能，一遍一遍的轮训检测非常费性能
表达式编译机制，相当于写了一个小型编译器，但也仅仅是编译器的前端部分，编译器的后端部分，即中间代码生成、优化（平台相关优化、平台无关优化）、目标代码生成等难点还是没有涉及
依赖注入的延迟加载问题：依赖注入本身很简单，但引入延迟加载之后非常复杂，大概是通过两个Cache对象来做的，instanceCache和providerCache，instanceCache里面存放已经实例化好了的服务，而providerCache中存放着服务提供商，也就是还没被实例化的服务
指令系统中的链接机制：分了好几层，套了4层闭包，非常绕，但是最终的落脚点还是directive指令上link函数的执行，双向数据绑定就在这里面发挥了威力


近两年规划：
1、计算机体系部分：组成原理、操作系统、汇编语言、C/C++、编译原理、指令集、Java（主要学习语言的设计、接口如何封装）
2、计算机网络：自顶向下方法 TCP/IP
3、算法：算法导论
4、基础学科：高等数学 线性代数 概率论 复变函数 离散数学 图论 英语

近五年规划：
以上基础学科差不多了之后可以看一下
深入理解Java虚拟机
Linux内核
浏览器实现原理

关于面试官提问还有什么问题想要问：
目前所应聘部门是什么情况
从技术上讲需要做什么准备
培训、晋升渠道
技术分享会
年度评级











