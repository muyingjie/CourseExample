面试准备：
工作经验介绍部分：
截止目前，js css所开发的比重大约8:2左右
最近做的一个项目是一个在线商城系统，用户可以在官网上注册一个商城，注册时需要输入一个二级域名，注册成功之后会给用户开通一个商城，用户可以通过这个二级域名访问商城的前台和后台，商城可以免费试用一段时间，试用期到了之后需要购买，对于不同需求、不同行业的商家，提供了不同的模板，如果需要某套模板需要单独购买，用户还可以进入会员中心，在会员中心中可以看到之前产生的商城、模板等订单信息。对于公司内部运营人员还有运营后台，新做的模板可以通过运营后台上传到官网，运营后台中还可以看到所有注册的用户，用户发起的发票申请，商城备案信息等等，此外还有移动端商城
上面提到了几个系统：业务官网、会员中心、商城前台、商城后台、模板市场、运营平台、移动端商城
业务官网：一个普通的企业站，除了登录注册之外没什么复杂交互
会员中心：最开始采用传统的后台渲染方式，后台采用的传统的MVC架构，html页面在控制器中被include进来，控制器中将页面中需要的变量通过assign方法传过去，模板中通过twig模板引擎渲染，后期我用Angular重构了，将渲染的部分放到前端，前端和后台之间通过json传递数据，在前端抽出一个服务来发送请求，该服务会在请求发出之前更新本地存储的最近一次发请求的时间戳，这个时间戳大于设置的session时间时，重定向到登录。
商城前台：和模板市场实际上是一个东西，刚买来商城的时候的前台实际上是就是一套默认模板，数据库中有一张表专门用于存储用户买来了的所有模板，还有一个字段用来存储当前用户使用哪一套模板，模板里面被拆成了很多组件，比如购物车、资讯、版权、logo等等组件，每个组件的模板单独维护，每个组件中的数据都从后台某个模块中的某个类中的某个方法里取到，每个页面里面用一个个标签去代表这一个个组件，类似于JSP页面中的自定义JSP标签，这一套模板里面这么多的后台方法的信息都会统一放到模板文件夹下的一个初始化文件中，这个文件是json格式的，相当于一个很大的配置文件，当切换模板的时候（刚注册开通商城时其实也算一次特殊的切换）会执行一个叫做初始化的操作，这个操作会在模板目录下生成一系列把原来组件解析好之后的页面，当前台访问这个页面的时候再去调用各个方法将其静态化。
商城后台：后台管理系统的页面一般都是左侧导航，点击导航中每一项之后在右侧显示出对应的增删改查的页面，后台PHP依然采用传统的MVC三层架构，前台的架构是外层一个父页面，子页面套了一个iframe，父页面中包含菜单导航，点击菜单中的每一项就刷新iframe中的页面，前端采用了seajs做模块化，这个项目我来了之后基本上做完了，后来商品模块实在是太乱了，我和一位后台的同事合作重构了一遍，添加修改商品的逻辑非常复杂
运营后台：完全是我主导的，用Angular做的，前后台之间也是通过json数据格式交互，后台采用了微服务架构，形式和会员中心差不多
移动端商城：主要用了zepto，css3的一些东西，实际上就相当于一套特殊的模板，后台入口中判断了一下请求是从移动端来的还是从pc端来的，我猜测是通过http请求头来判断的，判断出来是从移动端来的之后读取某一个特殊的模板文件夹下的内容（其实就是专门放移动端模板的那个目录），当然这里面的问题还有非常多，比如pc端的列表页都是同步获取，而移动端是异步获取，pc端和移动端的图片都用了一套，图片尺寸的问题等等

在此之前用Angular做过pc端类似后台管理系统的应用，和Angular+ionic的webapp应用

封装表单校验插件的时候总结出来了一个结论：差别比较大的场合没有必要一定抽象在一起，商场里面的表单校验有两大种交互方式：第一种就是如果表单填写有误就直接在表单后面附加错误，还有一种交互就是表单填写错误时将错误信息同一提示到最上方的一个容器中，当时只是想着得把所有的校验放一起，没想过这两种交互方式差别过大，并不适合放在一起，通过分析，需要多传给插件几个参数，首先得告诉插件是哪种错误校验情况，然后如果是统一放置错误信息的话得再传入放错误信息的容器参数，这样一来就很复杂了，不如把这两种情况分开

基本概念介绍部分：
变量：变量实际上就是内存中的一块空间，Js中基本类型的变量直接存放在栈空间中，引用类型的变量存放在对空间中，在栈中仅仅存放引用对象在堆中的地址，因此如果一个变量a存储了对象的引用，通过a.xxx修改的都是堆空间中同一个对象的值，而给该变量赋值就会将栈中存储的引用地址覆盖了，该变量也就不会对堆空间中的对象有引用关系了，当这块堆空间没有任何引用指向它的时候，浏览器会启用垃圾回收机制将其回收。
函数和预解析机制：放到这里目的是想和后面提到的预解析机制一起说一下，变量和函数的提升就不用说了，只要是前端肯定都知道，我想说的是这里面比较容易出错的地方：首先就是函数分为函数表达式和函数定义，只要不是以function关键字开头的都叫做函数表达式，包括var fn = function(){}; 匿名寒素自执行的情况，函数表达式不进行提升，即使在函数自执行中给函数命了名字，也不会提升，还有就是函数和变量同名时会覆盖变量的声明，但是需要注意在变量声明并赋值的场合中这个名字又被覆盖回去了，因为变量赋值这一步操作紧跟在预解析后面，而且一旦给变量初始化了，咱们开发人员就没有权限在变量和函数提升完毕和变量初始化赋值的中间间隙中做操作了，因此和函数同名的变量赋值之后弹出来这个名字不再是函数。
闭包：在说闭包之前首先要说作用域，在ES6之前Js中只有全局作用域和函数作用域，正常情况下当一个函数在执行时会把它用到的局部变量、函数的引用放在在栈空间，函数执行结束后这段栈空间中的局部变量、函数引用被释放，但是有一种情况比较特殊，当一个函数的返回值是一个函数、而且该函数中引用了父函数的变量的时候，即使父函数执行完，栈空间中的变量也不会从内存中释放，因为我在外部调用返回回来的这个函数时还可能用到这个变量，所以不能被释放，这就是闭包。说完闭包的概念，必然要说一下闭包的使用：可以总结为一句话：当希望外部使用但是得按照某种规则使用某个变量时，这个变量可以考虑使用闭包。例如封装一个弹框的插件，大体思路就是在全局扩展一个dialog方法，当需要页面中某个操作需要弹框时调用这个dialog方法并传入对应参数即可，但一个页面里面可能会有多个弹框，因此需要有种机制唯一标识每个弹框，这个唯一标识我们可以采用一个每次自增的变量，即调用一次dialog自增1，这个功能就可以用闭包实现，具体实现的流程就是将一个函数调用赋给dialog方法，这个函数调用返回实际的处理弹框的业务逻辑，这个函数内部放一个变量，在返回的那个函数中让变量自增，这样就可以保证dialog插件调用一次这个变量就自增一次，然后拿去用，有点类似于设计模式中的门面模式但又不太一样。实际上在很多库和框架内部都用到了这种思想，比如说我研究过的jquery和angular，jquery的Callbacks回调模块提供了对函数的统一管理，Callbacks模块里面定义了一个list的变量，通过$.Callbacks("once memory")调用方式可以返回一个对象，这个对象下的各个方法可能会对list这个变量进行操作，这Callbacks肯定执行完了，但是list肯定不能被释放，因为我外部还有可能进行add remove等等操作去对这个list变量做修改。同样的套路还用在了angular的模块管理(angular.module)，以及每个模块下调用directive service provider constant等等，内部有一个moduleInstance变量，刚才说的这些操作实际上都是对moduleInstance或moduleInstance下面的_invokeQueue队列进行操作，同样moduleInstance也会常驻在内存中，还有函数也可以看成实例化对象，那么函数实例化对象的方法有很多也用到了闭包，例如call apply bind，因为这些方法也要返回一个函数
作用域链：作用域这个东西虽然隐藏在js代码的字里行间，但是在浏览器底层实现的时候是有实实在在的作用域对象，我之前看V8内核的时候见到过Scope构造函数，函数在调用时会形成栈结构，每个函数都有自己第一个作用域，这个作用域对象上的各个属性和方法就是在这个函数里面定义的局部变量和局部函数，当在函数中访问一个变量时，会现在当前作用域对象上遍历查看是否有该名字的变量或函数，如果没有就沿着函数定义时所处的环境（注意并不是函数调用时所处的环境）层层向上查找然后执行，如果还是没找到就会做一定处理，例如如果给一个未定义过的变量赋值，实际上这个变量就会扩展到全局对象上，而如果直接通过a.xxx而a不存在的时候直接就报错can't read xxx of undefined，当执行a()时就会报a is not a function
原型链：每个对象都有一个隐藏的属性__proto__，这个__proto__属性指向该对象的原型对象，所谓原型对象就是存放一类对象的公共属性和方法的对象，因为没有必要给每个对象都存储一份这些公共的属性和方法，因此出现了原型对象，而原型对象也是对象，只要是对象就会有__proto__，因此原型对象也有这个属性，指向更高一级的对象，一直往上指，知道Object.prototype，Object.prototype的__proto__值就成了null，对象的__proto__和生产该对象的构造函数的prototype属性的指向是一样的，都指向原型对象，因此在封装构造函数实现面向对象功能并给公共对象扩展方法的时候通常都是构造函数.prototype.xxx这样扩展
事件：js中的事件分为3个阶段：捕获阶段、目标阶段、冒泡阶段，低版本IE不支持捕获，事件的委托是基于事件冒泡的，事件委托主要用于给将来的元素绑定事件时用到
面向对象：主要说下继承，子类继承父类时传统的方法就是将父类的一个实例化对象赋给子类的原型，然后子类构造函数中再用call或apply调用父类构造函数，需要注意为子类扩展方法时一定要在父类实例化对象赋给子类原型这一步之后，主要为防止一些垃圾方法扩展到父类上，此外还得把子类的constructor改成子类构造函数，因为浏览器解释js的时候遇到{}就会认为是一个对象，其constructor实Object，所以需要修正。这种传统的实现方式有一些问题，在这个过程中我们实例化了一个父类对象，相当于调用了一次父类构造函数，但是这次调用明显是多余的，因为我们的本质目的是希望得到一个原型是父类原型的一个对象，目前采用的方式是实例化父类，这当然没问题，但是当父类中代码很多，逻辑很复杂时，对性能会造成很大影响，因此我们可以单独定义一个空的构造函数，让这个构造函数的prototype指向父类的构造函数的prototype，再将这个空函数的实例化对象赋给子类原型，这就是所谓的寄生组合式继承，而回顾这个过程我们发现，我们其实就是想要一个原型是父类.prototype的一个对象，这个功能已经被ESMA5规范化，直接使用Object.create(Parent.prototype)即可，而ECMA6直接屏蔽了所有这些复杂的操作，直接采用extend关键字，继承方式和Java完全相同了
Function.prototype.bind:
Function.prototype.bind = Function.prototype.bind || function(){
    var args = Array.prototype.slice.call(arguments);
    var context = args[0];
    var fnArgs = args.slice(1);
    var _this = this;
    var fnnoop = function(){};
    fnnoop.prototype = this.prototype;

    // 如果直接这样返回，外部通过new调用时返回的是下面这个函数的实例化对象，而不是this指向的函数
    return function (){
        var inArgs = Array.prototype.slice.call(arguments);
        _this.apply(this instanceof fnnoop ? this : context, fnArgs.concat(inArgs));
    };
};
Function.prototype.bind = Function.prototype.bind || function(){
    var args = Array.prototype.slice.call(arguments);
    var context = args[0];
    var fnArgs = args.slice(1);
    var _this = this;
    var fnnoop = function(){};
    fnnoop.prototype = this.prototype;

    var fnRet = function (){
        var inArgs = Array.prototype.slice.call(arguments);
        return _this.apply(this instanceof fnnoop ? this : context, fnArgs.concat(inArgs));
    };
    fnRet.prototype = new fnnoop();
    return fnRet;
};
设计模式：
桥接模式 迭代器模式 装饰者模式 职责链模式
观察者模式：多处绑定，一处执行，对于执行完之后再绑定的函数直接执行，主要运用场景有jquery事件、Deferred模块、angular脏检测模块，操作系统中硬件相关操作也用了该模式：网卡负责了所有正在运行的服务的网络请求，每个应用会通知网卡在请求成功的时候执行某些操作，这就是订阅过程，当收到远程服务器发来的请求时会通过端口号判断去发布执行哪些绑定的操作，键盘，鼠标的交互也是同样的道理

移动端开发：
对于一侧固定，另外一侧自适应的布局用calc("100% - 13rem");

对于横向列表：width用百分比、高度写死时，很难实现正方形或者特定比例的效果，而且由于不同屏幕尺寸不同，用百分比的话也会出现各种不同的尺寸，而设计图只有一种尺寸，造成很大的不便，因此我们可以通过js计算出缩放比后动态生成meta标签附加上去

jQuery原理部分：
整体架构和链式调用：匿名函数自执行传入window可以在压缩时缩小体积，也可以缩短作用域链的查找，不必到最外层去找window了，而关于链式调用，则是返回了new jQuery.prototype.init()这样一个实例化对象，但是jQuery.prototype.init和jQuery毕竟是两个不一样的函数，而attr click等这些方法仅仅是在jQuery.prototype上的，因此，如果我们希望new jQuery.prototype.init()返回的对象也有这些方法，只需要将其原型指向jQuery.prototype.init的原型即可。于是jQuery.prototype.init.prototype = jQuery.prototype就出现了
Callbacks回调模块：对外提供了一套管理函数的接口，而且还有不同的模式，需要注意的是添加回调时如果回调队列已经触发完了，刚add进来的函数会立即执行，如果队列还没有fire完的时候又执行fire了，后一次的fire会被暂时缓存到一个栈中，当前一次fire执行完毕的时候判断一下栈是否有值，如果有的话取出继续执行
Deferred延迟对象模块：内部依赖3个Callbacks回调模块，分别是成功回调，失败回调，notify回调，分别供外部添加、执行对应的函数，需要特别说明的是pipe方法，pipe是提供链式调用的一个方法，每次在回调中return回去的值将作为下一个函数的参数，这其中的原理是pipe里面又返回了一个新的Deferred对象，所以链式调用pipe的时候传入的回到会添加到这个新的Deferred对象的回调列表中，当最开始的deferred对象执行发布操作时（例如resolve），会遍历其回调列表，列表中每一项实际上是一个对象，该对象中存储了pipe里面new出来的Deferred以及添加的回调，这个new出来的Deferred会继续调用它的resolve方法，将回调的返回值作为参数传入resolve中，但是当回调的返回值又是一个Deferred对象的时候，也就是想在回调中执行某些异步操作，当该操作resolve的时候再往下走的时候，下一个Deferred对象的resolve会被延迟，延迟到回调中延迟对象resolve了以后再去执行，实现这个功能的方法是将pipe里面创建的Deferred对象的发布操作（例如resolve）作为一个回调放到回调中创建的Deferred对象的回调列表中，也就是把pipe中的回调延迟到了pipe回调函数中创建的回调发布的时候执行
关于Deferred必须要注意的是链式的写法和在一个Deferred对象上多次通过then绑定效果是不一样的，内部处理也截然不同
Promise是只读Deferred
Data数据缓存模块：给DOM对象一个特殊的属性（该属性通常是引入jQuery的唯一标识），属性值为内部维护的自增的整数值，Data模块内有一个很大的对象用来存储所有的数据缓存，该对象的第一维的key是刚才提到的每个自增的整数值，value是存储在这个对象上的缓存数据，其中value又是一个很大的对象，对象的key为具体缓存的数据的名称，value为缓存的数据的值，至于缓存接口的具体实现，实在没什么好说的了，实例方法调原生方法，原生方法实现最终的设置操作
queue队列模块：queue方法是入队，dequeue是出队，可以通过queue链式调用让函数一个个入队，队列是基于数据缓存模块来实现的，当调用queue方法创建一个名为aaa的队列时，会为DOM对象扩展一个名为aaaqueue的缓存数组，之后名为aaa的入队操作都会push到这个缓存数组中，入队函数在将来执行时会传入下一个队列函数，入队函数需要手动调用该回调函数才可以实现队列功能，对于非动画类型的队列，需要手动执行dequeue，对于动画队列添加完之后就会出队执行。
event事件模块：比较复杂，主要分绑定事件(on实例化方法 add静态方法)、移除事件(off实例化方法 remove静态方法)、触发执行事件(trigger实例化方法 dispatch静态方法)，实例化方法主要用来兼容各种传参情况，真正功能的实现都在静态方法中，整个事件系统基于数据缓存模块实现，add添加的时候会在DOM对象对应的数据缓存中添加两部分内容：handle、events，events就是用来放事件相关信息的，注意并不是把事件函数直接放进去完事，而是放了一个个对象，每个对象对应一个事件函数，这个对象的属性有type(事件类型)、selector(用于处理委托的情况)、handler(事件函数)、guid(每个事件函数的唯一id)、namespace(方便将来移除的时候使用)，而handle缓存是一个函数，该函数内部会根据不同的情况(普通的事件触发还是委托)做不同的处理，事件触发分为浏览器触发和手动通过trigger触发，触发的时候实际走的都是handle缓存中的那一个主分发函数而不是events中各个监听函数
ajax交互模块：
animate动画模块：

Angular原理部分：
脏检测机制：每一个controller或者directive都有对应的作用域，其中controller是继承了父级的作用域(rootScope)，directive可以通过参数配置(独立的作用域还是继承父级的作用域)，每个作用域对象上可以绑定很多属性，每个属性都对应一个watch监听，所有的watch监听构成一个监听数组，当发生交互行为时，例如定时器、事件、ajax等会遍历监听函数里面的每个watch，查看其附加的属性值相对于前一次是否有变化，如果有变化就执行对应的操作，如果执行该操作的同时又造成了scope上其他属性的变化会再次循环该scope上的所有watch，直到所有watch都不变稳定下来，除此之外还可以在父级scope某个属性发生变化时通知所有子级scope上的属性进行检测，或者子级上某个属性发生变化时冒泡到父级上进行检测
表达式编译机制：写在html中的用双花括号包起来的或者写在指令中的部分(暂且叫做token)都对应所处scope上的某个属性，Angular内部会调用表达式编译模块来将其翻译成一个函数，该函数最终会加入到脏检测循环队列中，解析过程分为词法分析生成token串(实际上就是一个很大的数组)、语法分析(生成AST树)、根据AST树解析成对应的监听函数
依赖注入机制：依赖注入的出现是为了避免函数调用中耦合度过高的情况，例如某个函数中需要借助很多功能模块来实现，那么这些功能模块名会作为函数形参，函数内部可以直接拿来用，这里的函数形参是不能随便乱写的，必须写成规定的名字，这个规定的名字就是实现这个功能模块时所注册的名字，Angular依赖注入模块内部会将所有注册的功能模块放在一起形成一个叫做注入器的东西，然后该函数在调用时从形参中找到依赖的各个功能模块名，再借助注入器找到这些模块名对应的实体，这些实体将作为实参传入，这样就实现了各模块之间的解耦，现在关键问题来了，注入器怎么能通过函数的形参去找到所有的功能模块名，再去找到对应的功能模块呢？实际上我们可以通过调用函数的toString方法将函数变成一个字符串，再通过正则匹配到函数的参数，这样就拿到了所有的功能模块名，再去用注入器找各个模块，但是这样还是有个问题，那就是当代码压缩上传到服务器上时函数形参必然会被压缩，形参名还是变了，这样注入器寻找这些形参名对应的功能模块实体的话，必然出错，Angular内部有两种解决这个问题的办法：一种是给函数添加静态属性$inject，里面存放所有依赖的模块名，当然得是字符串类型的，另一种是定义模块时将参数变为数组，这个数组的最后一项放置真正的实现函数，前面所有项放置依赖的模块，当然也必须写成字符串类型
指令系统：指令是Angular这款框架的核心，指令系统相当于一个小型html编译器，Angular内部从ng-app根节点开始向后代遍历，查看每个节点上是否有指令（ECMA四种类型），找到指令时会看一下有没有注册过（即有没有通过directive注册过），如果注册过就拿出来用，事实上注册的每个directive就是定义了一套如何解析当前html节点的规则，directive内部会对html模板进行编译（主要是compile和link），最终生成目标页面

chrome调试：条件断点、不小心多摁了一下f10或f11还可以返回去


性能优化部分：所谓性能，就是用户做了某一个操作之后到得到响应所经历的时间间隔，这个间隔越长，性能越差，在传统后台MVC架构的情景中由后台V层将模板编译好之后生成静态html返回给客户端，而这样做服务器就需要花费一些精力解析模板，就对服务器造成了一定压力，而在采用了SPA架构之后后台无需编译html模板（即无需使用模板引擎），而是直接在controller层定义某个方法，返回json数据即可，那么html页面中就可以直接通过ajax调用服务器C层的一个方法，拿到这个json数据之后由浏览器进行解析，这样就可以减轻服务器压力，为什么可以减轻服务器压力呢？是因为服务器端不需要解析html模板了，html将直接作为纯静态资源返回给浏览器，现在经典的架构是用户直接访问的是代理服务器或者CDN，代理服务器再访问应用服务器，而后台的M层和C层都在应用服务器上放着，静态资源都在代理服务器上放着，因此浏览器请求静态资源时直接从代理服务器上拿就可以了，不需要进入到应用服务器拿数据了，因此节省了服务器压力，这是从整体架构上考虑性能问题，而事实上在采用SPA架构之后根据经验发送ajax的频率会很高，因此浏览器端做的操作应该是尽量少发请求，因此用到了请求合并，请求合并的多了每个包就大了，因此需要进行请求的压缩，当然这些都需要前后端的协调配合，协调一下哪些请求可以合并，而前端也需要做数据的持久化存储，为了减少请求次数，前端的代码合并必不可少，为了减少请求时包的长度，前端的代码压缩必不可少，此外就要考虑前端自身的优化了，例如DOM操作的优化、GPU加速等等

http和websocket部分：

自己遇到的难点：
添加商品的时候组合算法
jQuery内部sizzle引擎：词法解析、语法解析生成AST，当有伪类的时候，按照前序遍历算法执行，没有伪类的时候按照后序遍历算法执行
脏检测时如何提升性能，一遍一遍的轮训检测非常费性能
表达式编译机制，相当于写了一个小型编译器，但也仅仅是编译器的前端部分，编译器的后端部分，即中间代码生成、优化（平台相关优化、平台无关优化）、目标代码生成等难点还是没有涉及
依赖注入的延迟加载问题：依赖注入本身很简单，但引入延迟加载之后非常复杂，大概是通过两个Cache对象来做的，instanceCache和providerCache，instanceCache里面存放已经实例化好了的服务，而providerCache中存放着服务提供商，也就是还没被实例化的服务
指令系统中的链接机制：分了好几层，套了4层闭包，非常绕，但是最终的落脚点还是directive指令上link函数的执行，双向数据绑定就在这里面发挥了威力


近两年规划：
1、计算机体系部分：组成原理、操作系统、汇编语言、C/C++、编译原理、指令集、Java（主要学习语言的设计、接口如何封装）
2、计算机网络：自顶向下方法 TCP/IP
3、算法：算法导论
4、基础学科：高等数学 线性代数 概率论 复变函数 离散数学 图论 英语

近五年规划：
以上基础学科差不多了之后可以看一下
深入理解Java虚拟机
Linux内核
浏览器实现原理

关于面试官提问还有什么问题想要问：
目前所应聘部门是什么情况
从技术上讲需要做什么准备
培训、晋升渠道
技术分享会
年度评级











